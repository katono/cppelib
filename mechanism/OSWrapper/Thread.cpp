#include "Thread.h"
#include "ThreadFactory.h"
#include "Runnable.h"
#include "Assertion/Assertion.h"
#include <exception>

/*!
 * @brief OSWrapper provides abstract C++ interface of common RTOS: thread, mutex, event flag, message queue, memory pool, etc
 *
 * This class diagram shows the mechanism that isolates the client code from the code depended on the real RTOS.
 *
 * @startuml
 * package OSWrapper {
 *   abstract class Thread {
 *     {static} create(Runnable*) : Thread*
 *     {static} destroy(Thread*)
 *     {abstract} start()
 *   }
 *   interface ThreadFactory {
 *     {abstract} create(Runnable*) : Thread*
 *     {abstract} destroy(Thread*)
 *   }
 *   interface Runnable {
 *     {abstract} run()
 *   }
 * }
 *
 * package ItronOSWrapper {
 *   class ItronThread {
 *     kernel object ID
 *     start()
 *   }
 *   class ItronThreadFactory {
 *     create(Runnable*) : Thread*
 *     destroy(Thread*)
 *   }
 * }
 *
 * class UserTask << active >> {
 *   run()
 * }
 *
 * Thread <|-- ItronThread
 * ThreadFactory <|. ItronThreadFactory
 * Thread -> ThreadFactory
 * ItronThreadFactory ..> ItronThread : <<instantiate>>
 * Thread --> Runnable
 * Runnable <|.. UserTask
 * Client --> Thread
 * Client ..> UserTask
 * note right of Client : This depends on OSWrapper, but does\n not depend on ItronOSWrapper.
 * note "This item belongs to \n the most abstract layer." as N1
 * N1 .. OSWrapper
 * note "This is an example of RTOS.\n This item belongs to the most concrete layer \n that includes the code depended on the real RTOS." as N2
 * N2 .. ItronOSWrapper
 * note "MutexFactory, EventFlagFactory, etc \n are also the same structure as ThreadFactory." as N3
 * @enduml
 *
 * Factories of OSWrapper are the mechanism to call static methods (create(), destroy(), etc) as virtual methods.
 * Concrete factories are created as static objects and registered when the application is initialized.
 *
 * All the OS objects (Thread, Mutex, EventFlag, etc) are generated by create() static method
 * and released by destroy() static method.
 * The OS objects can be accessed with the pointer returned by create().
 * They can not be generated as stack objects by constructor.
 *
 * You can implement concrete classes for your OS platform like classes of ItronOSWrapper.
 */
namespace OSWrapper {

const int Thread::INHERIT_PRIORITY = -1;

static ThreadFactory* s_factory = 0;

void registerThreadFactory(ThreadFactory* factory)
{
	s_factory = factory;
}


Thread::UncaughtExceptionHandler* Thread::m_defaultUncaughtExceptionHandler = 0;

void Thread::setDefaultUncaughtExceptionHandler(Thread::UncaughtExceptionHandler* handler)
{
	m_defaultUncaughtExceptionHandler = handler;
}

Thread::UncaughtExceptionHandler* Thread::getDefaultUncaughtExceptionHandler()
{
	return m_defaultUncaughtExceptionHandler;
}

void Thread::setUncaughtExceptionHandler(Thread::UncaughtExceptionHandler* handler)
{
	m_uncaughtExceptionHandler = handler;
}

Thread::UncaughtExceptionHandler* Thread::getUncaughtExceptionHandler() const
{
	return m_uncaughtExceptionHandler;
}

void Thread::handleException(const char* msg)
{
#ifndef CPPELIB_NO_EXCEPTIONS
	try {
		if (m_uncaughtExceptionHandler != 0) {
			m_uncaughtExceptionHandler->handle(this, msg);
		} else if (m_defaultUncaughtExceptionHandler != 0) {
			m_defaultUncaughtExceptionHandler->handle(this, msg);
		}
	}
	catch (...) {
		// ignore exception
	}
#else
	(void)msg;
#endif
}

/*!
 * @brief Common thread main method
 * @note Called in the concrete class derived from Thread.
 */
void Thread::threadMain()
{
#ifndef CPPELIB_NO_EXCEPTIONS
	try {
#endif
		if (m_runnable != 0) {
			m_runnable->run();
		}
#ifndef CPPELIB_NO_EXCEPTIONS
	}
	catch (const std::exception& e) {
		handleException(e.what());
	}
	catch (const Assertion::Failure& e) {
		handleException(e.message());
	}
	catch (...) {
		handleException("Unknown Exception");
	}
#endif
}

Thread* Thread::create(Runnable* r, int priority/*= INHERIT_PRIORITY*/, std::size_t stackSize/*= 0U*/, void* stackAddress/*= 0*/, const char* name/*= ""*/)
{
	CHECK_ASSERT(s_factory);
	if (r == 0) {
		return 0;
	}
	return s_factory->create(r, priority, stackSize, stackAddress, name);
}

void Thread::destroy(Thread* t)
{
	if ((s_factory != 0) && (t != 0)) {
		s_factory->destroy(t);
	}
}

void Thread::sleep(unsigned long millis)
{
	CHECK_ASSERT(s_factory);
	s_factory->sleep(millis);
}

void Thread::yield()
{
	CHECK_ASSERT(s_factory);
	s_factory->yield();
}

Thread* Thread::getCurrentThread()
{
	CHECK_ASSERT(s_factory);
	return s_factory->getCurrentThread();
}

int Thread::getMaxPriority()
{
	CHECK_ASSERT(s_factory);
	return s_factory->getMaxPriority();
}

int Thread::getMinPriority()
{
	CHECK_ASSERT(s_factory);
	return s_factory->getMinPriority();
}

int Thread::getNormalPriority()
{
	CHECK_ASSERT(s_factory);
	return (s_factory->getMinPriority() + s_factory->getMaxPriority()) / 2;
}

int Thread::getHighestPriority()
{
	CHECK_ASSERT(s_factory);
	return s_factory->getHighestPriority();
}

int Thread::getLowestPriority()
{
	CHECK_ASSERT(s_factory);
	return s_factory->getLowestPriority();
}

int Thread::getPriorityHigherThan(int basePriority, int d)
{
	CHECK_ASSERT(s_factory);
	int ret = 0;
	if (getLowestPriority() < getHighestPriority()) {
		ret = basePriority + d;
	} else {
		ret = basePriority - d;
	}

	const int min = getMinPriority();
	if (ret <= min) {
		return min;
	}
	const int max = getMaxPriority();
	if (ret >= max) {
		return max;
	}
	return ret;
}

}
